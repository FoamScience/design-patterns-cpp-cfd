\section{Collective communication}

\begin{frame}[fragile]{Collective comms}
    When Two or more processes talk to each other.
    \begin{itemize}
        \item {\bf All processes} call the same function with the same set of arguments. 
        \item Although MPI-2 has non-blocking collective communications, OpenFOAM uses only the blocking variants.
        \item NOT a simple wrapper around P2P comms.
        \item OpenFOAM puts their interface in {\bf static public methods} of {\tt Pstream} class.
        \begin{itemize}
            \item Major differences in the API accross forks: (ESI and Foundation version) vs Foam Extend.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Collective comms}
    \begin{itemize}
        \item Most collective algorithms are $log(nProcs)$
        \item Gather (all-to-one), Scatter (one-to-all), All-to-All variants of all-to-one ones.
        \item OpenFOAM does not use all-to-one "reduce". What OpenFOAM calls a "reduce" is Gather+Scatter.
        \item MPI has also a "Broadcast" and "Barrier" but these are not used in OpenFOAM.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Collective comms: Gather (All-to-one)}
\begin{CodeEnvNoComment}[Check how something is distributed over processors]{cpp}{\scriptsize}
bool v = false;
if (Pstream::master()){ v = something(); } // <- must do on master
Pstream::gather(v, orOp<bool>());  // <- root process gathers
\end{CodeEnvNoComment}
\begin{figure}
    \begin{center}
    \begin{tikzpicture}
    \node[loris1, process] (p0) [label=above:{\scriptsize $P_0$}] {};
    \node[lownote,inner sep=0.5mm,fill=white,draw=white,text=white] (ln0) at (p0.south west)  {\tiny $v_0$};
    \node[lownote,inner sep=0.5mm,fill=mDarkTeal,draw=mDarkTeal] (ln0) at (p0.south west)  {\tiny \only<1>{$v_0$}\only<2>{$v_0$}};
    \node[loris2, process] (p1) at (6,0) [label=above:{\scriptsize $P_1$}] {};
    \node[lownote,inner sep=0.5mm,fill=white,draw=white,text=white] (ln1) at (p1.south west)  {\tiny $v_0 || v_1 || v_2$};
    \node[loris1, process] (p2) at (3,2) [label=above:{\scriptsize $P_2$}] {};
    \node[lownote,inner sep=0.5mm,fill=white,draw=white,text=white] (ln2) at (p2.south west)  {\tiny $v_0 || v_1 || v_2$};
    \node[lownote,inner sep=0.5mm] (ln2) at (p2.south west)  {\tiny \only<1>{$v_2$}\only<2>{$v_2$}};
    \uncover<2> {
        \node (c) at ($(p0)+(3,-1)$) {   };
        \draw[thick,draw=mDarkTeal,Tee Barb-] (p0) |- (c.west) node [near end,above, mDarkTeal] {\tt orOp()};
        \draw[thick,draw=mLightGreen,-Tee Barb] (c.east) -| (p1) node [near start,above,mLightGreen] {\tt orOp()};
        \draw[thick,draw=mDarkBrown,-Tee Barb] (c.north) -- (p2) node [midway,above,mDarkBrown,rotate=90] {\tt orOp()};

        %\node[node, image] (x_src_i) [right=of y_src_i, label=below:$\phi_j$] { };
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mLightGreen, minimum size=1mm, rotate=150, node distance=0,anchor=east] {};
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mDarkTeal, minimum size=1mm, rotate=30,node distance=0,anchor=east] {};
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mDarkBrown, minimum size=1mm, rotate=-90,node distance=0,anchor=east] {};
    }
    \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mLightGreen] (ln1) at (p1.south west)  {\tiny \only<1>{$v_1$}\only<2>{$v_0 || v_1 || v_2$}};
    \end{tikzpicture}
    \end{center}
    \caption{An example OpenFOAM gather operation (More like a MPI-reduce)}
    \label{fig:}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Collective comms: Gather (All-to-one)}
\begin{CodeEnvNoComment}[Check how something is distributed over processors (List-like)]{cpp}{\scriptsize}
List<bool> localLst(Pstream::nProcs(), false);
localLst[Pstream::myProcNo()] = something();
Pstream::gatherList(localLst); // <- root process gathers
\end{CodeEnvNoComment}
\begin{figure}
    \begin{center}
    \begin{tikzpicture}
    \node[loris1, process] (p0) [label=above:{\scriptsize $P_0$}] {};
    \node[lownote,inner sep=0.5mm,fill=mDarkTeal,draw=mDarkTeal] (ln0) at (p0.south west)  {\tiny $v_0$};
    \node[loris2, process] (p1) at (6,0) [label=above:{\scriptsize $P_1$}] {};
    \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mLightGreen,anchor=center] (ln1) at (p1.south)  {\tiny $v_1$};
    \node[loris1, process] (p2) at (3,2) [label=above:{\scriptsize $P_2$}] {};
    \node[lownote,inner sep=0.5mm,anchor=east] (ln2) at (p2.south east)  {\tiny $v_2$};
    \uncover<2> {
        \node (c) at ($(p0)+(3,-1)$) {   };
        \draw[thick,draw=mDarkTeal,Tee Barb-] (p0) |- (c.west) node [near end,above, mDarkTeal] {};
        \draw[thick,draw=mLightGreen,-Tee Barb] (c.east) -| (p1) node [near start,above,mLightGreen] {};
        \draw[thick,draw=mDarkBrown,-Tee Barb] (c.north) -- (p2) node [midway,above,mDarkBrown,rotate=90] {};

        %\node[node, image] (x_src_i) [right=of y_src_i, label=below:$\phi_j$] { };
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mLightGreen, minimum size=1mm, rotate=150, node distance=0,anchor=east] {};
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mDarkTeal, minimum size=1mm, rotate=30,node distance=0,anchor=east] {};
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mDarkBrown, minimum size=1mm, rotate=-90,node distance=0,anchor=east] {};
    }
    \node[lownote,inner sep=0.5mm,fill=white,draw=mDarkTeal,anchor=center] (ln0) at (p0.south)  {\tiny $v_0$};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mDarkTeal,anchor=east] (ln0) at (p0.south east)  {\tiny $v_0$};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mLightGreen,anchor=east] (ln1) at (p1.south east)  {\tiny $v_0$};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mLightGreen,anchor=west] (ln1) at (p1.south west)  {\tiny $v_0$};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mDarkBrown,anchor=center] (ln2) at (p2.south)  {\tiny $v_0$};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mDarkBrown,anchor=west] (ln2) at (p2.south west)  {\tiny $v_0$};
    \uncover<2> {
    \node[lownote,inner sep=0.5mm,fill=mDarkBrown,draw=mDarkBrown,anchor=east] (ln1) at (p1.south east)  {\tiny $v_2$};
    \node[lownote,inner sep=0.5mm,fill=mDarkTeal,draw=mDarkTeal,anchor=west] (ln1) at (p1.south west)  {\tiny $v_0$};
    }
    \end{tikzpicture}
    \end{center}
    \caption{Example OpenFOAM gather operation on list items}
    \label{fig:}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Collective comms: Scatter (One-to-all)}
\begin{CodeEnvNoComment}[Make processes know about something]{cpp}{\scriptsize}
bool v = false;
if (Pstream::master()){ v = something(); } // <- must do on master
Pstream::scatter(v);  // <- root process scatters
\end{CodeEnvNoComment}
\begin{figure}
    \begin{center}
    \begin{tikzpicture}
    \node[loris1, process] (p0) [label=above:{\scriptsize $P_0$}] {};
    \node[lownote,inner sep=0.5mm,fill=white,draw=white,text=white] (ln0) at (p0.south west)  {\tiny $v_0$};
    \node[lownote,inner sep=0.5mm,fill=mDarkTeal,draw=mDarkTeal] (ln0) at (p0.south west)  {\tiny \only<1>{$v_0$}\only<2>{$v_0$}};
    \node[loris2, process] (p1) at (6,0) [label=above:{\scriptsize $P_1$}] {};
    \node[lownote,inner sep=0.5mm,fill=white,draw=white,text=white] (ln1) at (p1.south west)  {\tiny $v_0 || v_1 || v_2$};
    \node[loris1, process] (p2) at (3,2) [label=above:{\scriptsize $P_2$}] {};
    \node[lownote,inner sep=0.5mm,fill=white,draw=white,text=white] (ln2) at (p2.south west)  {\tiny $v_0 || v_1 || v_2$};
    \node[lownote,inner sep=0.5mm] (ln2) at (p2.south west)  {\tiny \only<1>{$v_2$}\only<2>{$v_2$}};
    \uncover<2> {
        \node (c) at ($(p0)+(3,-1)$) {   };
        \draw[thick,draw=mDarkTeal,stealth-] (p0) |- (c.west);
        \draw[thick,draw=mLightGreen,-Tee Barb] (c.east) -| (p1);
        \draw[thick,draw=mDarkBrown,-stealth] (c.north) -- (p2);

        %\node[node, image] (x_src_i) [right=of y_src_i, label=below:$\phi_j$] { };
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mLightGreen, minimum size=1mm, rotate=150, node distance=0,anchor=east] {};
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mDarkTeal, minimum size=1mm, rotate=30,node distance=0,anchor=east] {};
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mDarkBrown, minimum size=1mm, rotate=-90,node distance=0,anchor=east] {};
        \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mLightGreen] (ln0) at (p0.south west)  {\tiny $v_1$};
        \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mLightGreen] (ln2) at (p2.south west)  {\tiny $v_1$};
    }
    \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mLightGreen] (ln1) at (p1.south west)  {\tiny \only<1>{$v_1$}\only<2>{$v_1$}};
    \end{tikzpicture}
    \end{center}
    \caption{An example OpenFOAM scatter operation (More like a MPI-Bcast)}
    \label{fig:}
\end{figure}
\end{frame}


\begin{frame}[fragile]{Collective comms: Scatter (One-to-all)}
\begin{CodeEnvNoComment}[Make processes know about something (List-like)]{cpp}{\scriptsize}
List<bool> localLst(Pstream::nProcs(), false);
if (Pstream::master()){ forAll(localLst, ei) { localLst[ei] = something(); } }
Pstream::scatterList(localLst); // <- root process scatters
\end{CodeEnvNoComment}
\begin{figure}
    \begin{center}
    \begin{tikzpicture}
    \node[loris1, process] (p0) [label=above:{\scriptsize $P_0$}] {};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mDarkTeal] (ln0) at (p0.south west)  {\tiny $v_0$};
    \node[lownote,inner sep=0.5mm,fill=mDarkTeal,draw=mDarkTeal] (ln0) at (p0.south west)  {\tiny $v_0$};
    \node[loris2, process] (p1) at (6,0) [label=above:{\scriptsize $P_1$}] {};
    \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mLightGreen,anchor=center] (ln1) at (p1.south)  {\tiny $v_1$};
    \node[loris1, process] (p2) at (3,2) [label=above:{\scriptsize $P_2$}] {};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mDarkBrown,anchor=east] (ln2) at (p2.south east)  {\tiny $v_2$};
    \node[lownote,inner sep=0.5mm,fill=mDarkBrown,anchor=east] (ln2) at (p2.south east)  {\tiny $v_2$};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mDarkTeal,anchor=center] (ln0) at (p0.south)  {\tiny $v_1$};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mDarkTeal,anchor=east] (ln0) at (p0.south east)  {\tiny $v_2$};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mDarkBrown,anchor=center] (ln2) at (p2.south)  {\tiny $v_1$};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mDarkBrown,anchor=west] (ln2) at (p2.south west)  {\tiny $v_0$};
    \uncover<2> {
        \node (c) at ($(p0)+(3,-1)$) {   };
        \draw[thick,draw=mDarkTeal,Tee Barb-] (p0) |- (c.west) node [near end,above, mDarkTeal] {};
        \draw[thick,draw=mLightGreen,-Tee Barb] (c.east) -| (p1) node [near start,above,mLightGreen] {};
        \draw[thick,draw=mDarkBrown,-Tee Barb] (c.north) -- (p2) node [midway,above,mDarkBrown,rotate=90] {};

        %\node[node, image] (x_src_i) [right=of y_src_i, label=below:$\phi_j$] { };
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mLightGreen, minimum size=1mm, rotate=150, node distance=0,anchor=east] {};
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mDarkTeal, minimum size=1mm, rotate=30,node distance=0,anchor=east] {};
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mDarkBrown, minimum size=1mm, rotate=-90,node distance=0,anchor=east] {};
    \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mDarkTeal,anchor=center] (ln0) at (p0.south)  {\tiny $v_1$};
    \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mDarkTeal,anchor=east] (ln0) at (p0.south east)  {\tiny $v_2$};
    \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mDarkBrown,anchor=center] (ln2) at (p2.south)  {\tiny $v_1$};
    \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mDarkBrown,anchor=west] (ln2) at (p2.south west)  {\tiny $v_0$};
    }
    \node[lownote,inner sep=0.5mm,fill=white,draw=mLightGreen,anchor=east] (ln1) at (p1.south east)  {\tiny $v_0$};
    \node[lownote,inner sep=0.5mm,fill=white,draw=mLightGreen,anchor=west] (ln1) at (p1.south west)  {\tiny $v_0$};
    \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mLightGreen,anchor=east] (ln1) at (p1.south east)  {\tiny $v_2$};
    \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mLightGreen,anchor=west] (ln1) at (p1.south west)  {\tiny $v_0$};
    \end{tikzpicture}
    \end{center}
    \caption{Example OpenFOAM scatter operation on list items}
    \label{fig:}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Collective comms: Reduce (All-to-All)}
\begin{CodeEnvNoComment}[Do something with a var on all processors (eg. sum them up)]{cpp}{\scriptsize}
// Second arg: a binary operation function (functors); see ops.H
Foam::reduce(localVar, sumOp<decltype(localVar)>());
localVar = Foam::returnReduce(nonVoidCall(), sumOp<decltype(localVar)>());
\end{CodeEnvNoComment}
\begin{figure}
    \begin{center}
    \begin{tikzpicture}
    \node[loris1, process] (p0) [label=above:{\scriptsize $P_0$}] {};
    \node[lownote,inner sep=0.5mm,fill=white,draw=white,text=white] (ln0) at (p0.south west)  {\tiny $v_0+v_1+v_2$};
    \node[lownote,inner sep=0.5mm,fill=mDarkTeal,draw=mDarkTeal] (ln0) at (p0.south west)  {\tiny \only<1>{$v_0$}\only<2>{$v_0+v_1+v_2$}};
    \node[loris2, process] (p1) at (6,0) [label=above:{\scriptsize $P_1$}] {};
    \node[lownote,inner sep=0.5mm,fill=white,draw=white,text=white] (ln1) at (p1.south west)  {\tiny $v_0+v_1+v_2$};
    \node[lownote,inner sep=0.5mm,fill=mLightGreen,draw=mLightGreen] (ln1) at (p1.south west)  {\tiny \only<1>{$v_1$}\only<2>{$v_0+v_1+v_2$}};
    \node[loris1, process] (p2) at (3,2) [label=above:{\scriptsize $P_2$}] {};
    \node[lownote,inner sep=0.5mm,fill=white,draw=white,text=white] (ln2) at (p2.south west)  {\tiny $v_0+v_1+v_2$};
    \node[lownote,inner sep=0.5mm] (ln2) at (p2.south west)  {\tiny \only<1>{$v_2$}\only<2>{$v_0+v_1+v_2$}};
    \uncover<2> {
        \node (c) at ($(p0)+(3,-1)$) {   };
        \draw[thick,draw=mDarkTeal,Tee Barb-] (p0) |- (c.west) node [near end,above, mDarkTeal] {\tt sumOp()};
        \draw[thick,draw=mLightGreen,-Tee Barb] (c.east) -| (p1) node [near start,above,mLightGreen] {\tt sumOp()};
        \draw[thick,draw=mDarkBrown,-Tee Barb] (c.north) -- (p2) node [midway,above,mDarkBrown,rotate=90] {\tt sumOp()};

        %\node[node, image] (x_src_i) [right=of y_src_i, label=below:$\phi_j$] { };
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mLightGreen, minimum size=1mm, rotate=150, node distance=0,anchor=east] {};
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mDarkTeal, minimum size=1mm, rotate=30,node distance=0,anchor=east] {};
        \node (s1) at (3,-1) [circular sector,circular sector angle=120,fill=mDarkBrown, minimum size=1mm, rotate=-90,node distance=0,anchor=east] {};
    }
    \end{tikzpicture}
    \end{center}
    \caption{An example OpenFOAM reduce operation (MPI-Allreduce)}
    \label{fig:}
\end{figure}
\end{frame}

\againframe<3>{f1}

\begin{frame}[fragile]{Collective comms: Issues}
You can still fall for endless loops if you're not careful!
\begin{CodeEnvNoComment}[Infinite loops due to early returns]{cpp}{\scriptsize}
void refineMesh(fvMesh& mesh, const label& globalNCells)
{
  label currentNCells = 0;
  do
  {
    // Perform calculations on all processors
    currentNCells += addCells(mesh);
    // On some condition, a processor should not continue, and
    // returns control to the caller
    if (Pstream::myProcNo() == 1) return; // <-- oops, can't do this
    // !!! who's going to reduce this!
    reduce(currentNCells, sumOp<label>());
  } while (currentNCells < globalNCells);
  return;
}
\end{CodeEnvNoComment}
\end{frame}

\againframe<4>{f1}
