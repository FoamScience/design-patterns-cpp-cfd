\section{Application examples \& advanced topics}

\newcommand{\highlight}[1]{\colorbox{mLightGreen!50}{$\displaystyle #1$}}

\begin{frame}[fragile]{Solving PDEs over decomposed domains (P2P comms)}
General Transport Equation for a physical transport property
$$
\partial_{t} \phi+\highlight{\nabla \cdot(\phi \mathbf{u})-\nabla \cdot(\Gamma \nabla \phi)}=S_{\phi}(\phi)
$$
Discretized form (Finite Volume notation)
$$
\llbracket \partial_{t}[\phi] \rrbracket+\highlight{\llbracket \nabla \cdot\left(F[\phi]_{f(F, S, \gamma)}\right) \rrbracket-\llbracket \nabla \cdot\left(\Gamma_{f} \nabla[\phi]\right) \rrbracket}=\llbracket S_{I}[\phi] \rrbracket .
$$

\begin{itemize}
    \item Receive neighbour values from neighbouring processor.
    \item Send face cell values from local domain to neighouring processor
    \item Interpolate to processor patch faces
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Adaptive Mesh Refinement on polyhedral meshes}

    \begin{enumerate}
        \item Refine each processor's part of the mesh, but we need to keep the global cell count under a certain value: 
    \end{enumerate}
\begin{CodeEnvNoComment}[Reduce nAddCells or nTotalAddCells?]{cpp}{\scriptsize}
label ?\color{mDarkBrown!90}{nAddCells}? = 0;
label nIters = 0;
label ?\alert{nTotalAddCells}? = 0;
do
{
    ?\color{mDarkBrown!90}{nAddCells}? = 0;
    if (edgeBasedConsistency_)
    {
        ?\color{mDarkBrown!90}{nAddCells}? += edgeConsistentRefinement(refineCell);
    }
    ?\color{mDarkBrown!90}{nAddCells}? += faceConsistentRefinement(refineCell);
    reduce(?\color{mDarkBrown!90}{nAddCells}?, sumOp<label>());
    ++nIters;
    ?\alert{nTotalAddCells}? += ?\color{mDarkBrown!90}{nAddCells}?;
} while (?\color{mDarkBrown!90}{nAddCells}? > 0);
\end{CodeEnvNoComment}
\end{frame}

\begin{frame}[fragile]{Adaptive Mesh Refinement on polyhedral meshes}

    \begin{enumerate}\addtocounter{enumi}{1}
        \item To decide on whether to refine cells at processor boundaries, we need cell levels from the other side:
    \end{enumerate}
\begin{CodeEnvNoComment}[Reduce nAddCells or nTotalAddCells?]{cpp}{\scriptsize}
// Code extracted from Foam Extend 4.1
labelList ownLevel(nFaces - nInternalFaces);
forAll (ownLevel, i)
{
    const label& own = owner[i + nInternalFaces];
    ownLevel[i] = updateOwner();
}

// Swap boundary face lists (coupled boundary update)
syncTools::swapBoundaryFaceList(mesh_, ownLevel, false);

// Note: now the ownLevel list actually contains the neighbouring level
// (from the other side), use alias (reference) for clarity from now on
const labelList& neiLevel = ownLevel;
\end{CodeEnvNoComment}
\end{frame}
